<!DOCTYPE html>
<html>
<head>
  <title>Tourist Route with Danger Zone Awareness</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.8.0/dist/geosearch.css" />
  <script src="https://unpkg.com/leaflet-geosearch@3.8.0/dist/bundle.min.js"></script>

  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <style>
    body, html { 
      margin:0; padding:0; height:100%; width:100%;
      display:flex; flex-direction:row;
    }
    #map { 
      flex: 1 1 auto;
      height:100%; 
      width:70%; 
    }
    #sidebar {
      width: 300px;
      max-width: 30%;
      height:100%;
      overflow-y:auto;
      background:white;
      padding:10px;
      box-shadow:-2px 0 6px rgba(0,0,0,0.2);
      z-index:1000;
    }
    #controls { margin-bottom:10px; }
    .route-info { border-bottom:1px solid #ddd; margin-bottom:10px; padding-bottom:10px; }
    .stop-input { margin-bottom:5px; width:100%; padding:6px; border:1px solid #ccc; border-radius:5px; }
    .start-options { display:flex; gap:10px; margin-bottom:5px; }
    button { margin-top:5px; padding:5px 10px; border:none; border-radius:5px; cursor:pointer; }

    /* --- Custom Popup Styling --- */
    .custom-popup .leaflet-popup-content-wrapper {
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        padding: 1px; /* Prevents content from touching the edge */
    }
    .custom-popup .leaflet-popup-content {
        margin: 15px;
        font-size: 14px;
        line-height: 1.4;
    }
    .custom-popup .leaflet-popup-tip-container {
        width: 40px;
        height: 20px;
        position: absolute;
        left: 50%;
        margin-left: -20px;
        overflow: hidden;
    }
    .custom-popup .leaflet-popup-tip {
        width: 15px;
        height: 15px;
        transform: rotate(45deg) translate(2px, -19px);
        box-shadow: 0 0 12px rgba(0,0,0,0.2);
    }

    /* Dark Theme (for danger zones) */
    .dark-popup .leaflet-popup-content-wrapper {
        background-color: #2c2c2e;
        color: white;
    }
    .dark-popup .leaflet-popup-tip {
        background: #2c2c2e;
    }

    /* Light Theme (for user location) */
    .light-popup .leaflet-popup-content-wrapper {
        background-color: white;
        color: #333;
    }
    .light-popup .leaflet-popup-close-button {
        color: #333;
    }
    .light-popup .leaflet-popup-tip {
        background: white;
    }
  </style>
</head>
<body>
  <div id="sidebar">
  <div id="controls">
    <div class="start-options">
      <label><input type="radio" name="startType" value="current" checked> Current Location</label>
      <label><input type="radio" name="startType" value="manual"> Select Location</label>
    </div>
    <input type="text" id="startInput" class="stop-input" placeholder="Start location" disabled />
    <div id="stops">
      <input type="text" class="stop-input" placeholder="Destination" />
    </div>
    <button id="addStop">+ Add Stop</button>
    <button id="routeBtn">Plan Routes</button>
    <button id="walkBtn" disabled>🚶 Start Walk</button>
    <button id="visualizeBtn" disabled>Visualize</button>
  </div>

  <h3>Available Routes</h3>
  <div id="routesList"></div>
</div>

  <div id="map"></div>

  <script>
    var map = L.map('map').setView([22.9734, 78.6569], 5); // India default

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    var routeLines = [];
    var currentLocation = null;
    var dangerZones = [];
    var dangerZoneLayers = L.layerGroup().addTo(map);
    var waypointLabels = []; // store labels for sidebar display
    let enteredZoneIds = new Set(); // Keep track of zones the user has entered
    let isVisualizing = false;

    // --- Cooldown timers --- //
    let lastDeviationAlert = 0;
    let lastDangerAlert = 0;
    let lastApproachingAlert = 0;
    const DEVIATION_COOLDOWN = 15000; // 15s
    const DANGER_COOLDOWN = 20000; // 20s
    const APPROACHING_COOLDOWN = 20000; // 20s

    function speak(text) {
    if ('speechSynthesis' in window) {
        // Cancel any speech in the queue
        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 1;   // Speed (0.1 to 10, default 1)
        utterance.pitch = 1;  // Pitch (0 to 2, default 1)
        utterance.volume = 1; // Volume (0 to 1)

        // Optional event listeners for debugging
        utterance.onstart = () => console.log("🔊 Speaking:", text);
        utterance.onend = () => console.log("✅ Finished speaking:", text);
        utterance.onerror = (e) => console.error("Speech error:", e);

        window.speechSynthesis.speak(utterance);
    } else {
        console.warn("Speech synthesis not supported. Falling back to alert.");
        alert(text);
    }
}


    function playAudioAlert() {
      const audio = new Audio('/static/alert.mp3');
      audio.play();
    }

    // India-only search provider
    const provider = new window.GeoSearch.OpenStreetMapProvider({
      params: { countrycodes:"IN", bounded:1 }
    });

    // Autocomplete search
    async function attachSearch(input) {
      input.addEventListener("input", async function () {
        const query = input.value;
        if (query.length < 3) return;
        const results = await provider.search({ query });
        
        document.querySelectorAll(".suggest-list").forEach(el=>el.remove());

        let list = document.createElement("div");
        list.className = "suggest-list";
        list.style.background="white"; list.style.border="1px solid #ccc";
        list.style.position="absolute"; list.style.zIndex="1001";
        list.style.width=input.offsetWidth+"px";
        list.style.maxHeight="150px"; list.style.overflowY="auto";
        let rect = input.getBoundingClientRect(); 
        list.style.left = rect.left + "px"; 
        list.style.top = rect.bottom + "px";

        results.forEach(r => {
          let item = document.createElement("div");
          item.innerHTML=r.label; item.style.padding="5px"; item.style.cursor="pointer";
          item.onclick=()=>{ 
            input.value=r.label; 
            input.dataset.lat=r.y; 
            input.dataset.lng=r.x; 
            document.body.removeChild(list); 
          };
          list.appendChild(item);
        });
        document.body.appendChild(list);
      });
    }

    document.querySelectorAll(".stop-input").forEach(attachSearch);

    document.getElementById("addStop").onclick=function(){
      let newInput=document.createElement("input");
      newInput.type="text"; newInput.className="stop-input"; newInput.placeholder="Add stop";
      document.getElementById("stops").appendChild(newInput);
      attachSearch(newInput);
    };

    document.querySelectorAll("input[name='startType']").forEach(radio=>{
      radio.addEventListener("change",function(){
        let startInput=document.getElementById("startInput");
        if(this.value==="manual"){ startInput.disabled=false; attachSearch(startInput); }
        else { startInput.disabled=true; startInput.value=""; delete startInput.dataset.lat; delete startInput.dataset.lng; }
      });
    });

    // Fetch and draw danger zones
    function fetchAndDrawZones() {
        fetch("/get_zones")
            .then(res => res.json())
            .then(data => {
                dangerZones = data;
                dangerZoneLayers.clearLayers();
                dangerZones.forEach(dz => {
                    let color;
                    if (dz.type === 'disaster') {
                        color = 'orange';
                    } else if (dz.type === 'manual') {
                        color = 'red';
                    } else {
                        color = 'blue';
                    }
                    const circle = L.circle([dz.lat, dz.lng], { radius: dz.radius, color: color, fillOpacity: 0.3 })
                        .addTo(dangerZoneLayers);

                    // Show popup on click
                    circle.on('click', function (e) {
                        L.DomEvent.stop(e); // Stop propagation to map click
                        const popup = L.popup({
                                className: 'custom-popup dark-popup',
                                closeButton: false,
                                autoClose: false,
                                closeOnClick: true
                            })
                            .setLatLng(e.latlng)
                            .setContent(dz.description || 'No description provided.')
                            .openOn(map);

                        // Close popup after 10 seconds
                        setTimeout(() => {
                            if (map.hasLayer(popup)) {
                                map.closePopup(popup);
                            }
                        }, 10000);
                    });
                });
            });
    }

    // Initial fetch
    fetchAndDrawZones();

    // Poll for updates every 10 seconds
    setInterval(fetchAndDrawZones, 10000);

    // Convert circle to polygon
    const circlesToPolygons = (circles) => {
    return {
        "type": "FeatureCollection",
        "features": circles.map((circle, index) => {
            let point = turf.point([circle.lng, circle.lat]);
            let buffered = turf.buffer(point, circle.radius / 1000, {
                units: 'kilometers',
                steps: 32
            });

            let coordinates = buffered.geometry.coordinates[0];
            if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] ||
                coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
                coordinates.push(coordinates[0]);
            }

            return {
                "type": "Feature",
                "id": `danger_zone_${index}`,
                "properties": {},
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [coordinates]
                }
            };
        })
    };
};

    // Plan routes
document.getElementById("routeBtn").onclick = async function() {
    routeLines.forEach(l => map.removeLayer(l.line));
    routeLines = [];
    document.getElementById("routesList").innerHTML = "";

    let waypoints = [];
    waypointLabels = [];

    let startType = document.querySelector("input[name='startType']:checked").value;
    if (startType === "current" && currentLocation) {
        waypoints.push([currentLocation.lng, currentLocation.lat]);
        waypointLabels.push("Current Location");
    } else {
        let s = document.getElementById("startInput");
        if (s.dataset.lat && s.dataset.lng) {
            waypoints.push([parseFloat(s.dataset.lng), parseFloat(s.dataset.lat)]);
            waypointLabels.push(s.value);
        }
    }

    document.querySelectorAll("#stops .stop-input").forEach(inp => {
        if (inp.dataset.lat && inp.dataset.lng) {
            waypoints.push([parseFloat(inp.dataset.lng), parseFloat(inp.dataset.lat)]);
            waypointLabels.push(inp.value);
        }
    });

    if (waypoints.length < 2) {
        speak("Please set at least a start and destination");
        return;
    }

    let polygons = circlesToPolygons(dangerZones);

    for (let i = 0; i < waypoints.length-1; i++){
    let body = {
        points: [waypoints[i],waypoints[i+1]],
        profile: "car",
        locale: "en",
        instructions: true,
        calc_points: true,
        points_encoded: false,
        algorithm: "alternative_route",
        alternative_route: {
            max_paths: 3
        }
    };

    if (polygons.length > 0) {
        body.custom_model = {
            priority: [
                { "if": "in_area(\"danger_zones\")", "multiply_by": 0.01 }
            ],
            areas: { "danger_zones": { type: "FeatureCollection", features: polygons.features } }
        };
    }

    let url = "https://graphhopper.com/api/1/route?key=da1e475d-18d1-41c5-b870-433cc6dee1cf";

    try {
        let res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        });

        let data = await res.json();

        if (res.status >= 400) {
            speak("Error from routing service: " + (data.message || "Unknown error"));
            return;
        }

        if (!data.paths || data.paths.length === 0) {
            speak("No safe route found!");
            return;
        }

    data.paths.forEach((p, idx) => {
        const uniqueId = `leg${i}-alt${idx}`;
        let coords = p.points.coordinates.map(c => [c[1], c[0]]);

        let routeLine = turf.lineString(p.points.coordinates);

        let isDangerous = false;
        polygons.features.forEach(poly => {
            if (turf.booleanIntersects(routeLine, poly)) {
                isDangerous = true;
            }
        });

        let color = isDangerous ? "red" : (idx === 0 ? "blue" : "gray");
        let line = L.polyline(coords, { color: color, weight: 5, opacity: 0.9 }).addTo(map);

        routeLines.push({ id: uniqueId, line: line, coords: coords, isDangerous: isDangerous, leg: i, alt: idx });
        if (idx === 0) map.fitBounds(line.getBounds());

        addRouteToList(uniqueId, p, isDangerous, waypointLabels[i], waypointLabels[i+1]);
});
    } catch (error) {
        speak("Error connecting to routing service. Check your connection or the API key.");
    }
}

    // Send the first safe route to the backend for training
    const firstSafeRoute = routeLines.find(r => !r.isDangerous);
    if (firstSafeRoute) {
        sendPlannedPath(firstSafeRoute.coords);
    }
};

let selectedRouteId = null;
let walkMarker = null;

function animateWalk(routeObj, speed = 1000) {
    if (walkMarker) {
        map.removeLayer(walkMarker);
        walkMarker = null;
    }

    const selectedDiv = document.querySelector(`.route-info[data-id='${selectedRouteId}']`);

    document.getElementById("routesList").innerHTML = "";
    if (selectedDiv) {
        let clone = selectedDiv.cloneNode(true);
        clone.style.background = "#e0f7fa";
        document.getElementById("routesList").appendChild(clone);
    }

    routeLines.forEach(r => {
        if (r.id !== selectedRouteId) map.removeLayer(r.line);
    });

    let coords = [...routeObj.coords];
    if (currentLocation) {
        coords[0] = [currentLocation.lat, currentLocation.lng];
    }

    // Original route for deviation check. IMPORTANT: turf needs [lng, lat]
    const originalRouteLineString = turf.lineString(routeObj.coords.map(c => [c[1], c[0]]));

    let walkLine = routeObj.line;
    let i = 0;

    walkMarker = L.marker(coords[0], {
        icon: L.divIcon({ className: "walk-icon", html: "🚶", iconSize: [30, 30] })
    }).addTo(map);

    function move() {
        if (i < coords.length) {
            walkMarker.setLatLng(coords[i]);

            if (i >=10 && i<=20) {
                coords[i] = [
                    coords[i][0] + 0.002,   // shift ~2.2km north
                    coords[i][1] + 0.002   // shift ~2.2km east
                ];
            }

            if(isVisualizing) {
              map.setView(coords[i], 16);
            }
            // Check deviation from the original route
            let currentPoint = turf.point([coords[i][1], coords[i][0]]);
            let distance = turf.pointToLineDistance(currentPoint, originalRouteLineString, { units: 'meters' });
            console.log(distance,i)
            if (distance > 50) {
                let now = Date.now();
                if (now - lastDeviationAlert > DEVIATION_COOLDOWN) {
                    speak("Sir, you are deviating from the path.");
                    lastDeviationAlert = now;
                }
            }

            checkAnomaly(coords[i][0], coords[i][1]);

            let remaining = coords.slice(i);
            walkLine.setLatLngs(remaining);

            i++;
            setTimeout(move, speed);
        } else {
            walkMarker.bindPopup("🎉 Arrived at destination!").openPopup();
        }
    }

    move();
}


document.getElementById("walkBtn").onclick = () => {
    if (selectedRouteId === null) {
        speak("Please select a route first!");
        return;
    }
    const selectedRoute = routeLines.find(r => r.id === selectedRouteId);
    animateWalk(selectedRoute);
    document.getElementById("visualizeBtn").disabled = false;
};

document.getElementById("visualizeBtn").onclick = () => {
  isVisualizing = !isVisualizing;
  const btn = document.getElementById("visualizeBtn");
  if(isVisualizing) {
    btn.textContent = "Stop Visualizing";
    btn.style.background = "#f44336";
    btn.style.color = "white";
  } else {
    btn.textContent = "Visualize";
    btn.style.background = "";
    btn.style.color = "";
  }
}

function addRouteToList(id, p, isDangerous, startLabel, endLabel) {
    let routeName = `${startLabel} → ${endLabel}`;

    let div = document.createElement("div");
    div.className = "route-info";
    div.dataset.id = id;
    div.innerHTML = `<b>${routeName}</b><br>
        Distance: ${(p.distance/1000).toFixed(2)} km<br>
        Time: ${(p.time/60000).toFixed(1)} mins<br>
        ${isDangerous 
            ? "<span style='color:red;'>⚠ Crosses Danger Zone</span>" 
            : "<span style='color:green;'>✅ Safe</span>"}`;

    div.style.cursor = "pointer";

    div.onclick = () => {
        selectedRouteId = id;

        document.querySelectorAll(".route-info").forEach(el => el.style.background = "white");
        div.style.background = "#e0f7fa";

        routeLines.forEach(r => {
            const isSelected = r.id === selectedRouteId;
            const defaultColor = r.isDangerous ? "red" : (r.leg === 0 && r.alt === 0 ? "blue" : "gray");
            r.line.setStyle({ 
                color: isSelected ? "orange" : defaultColor, 
                weight: isSelected ? 8 : 5, 
                opacity: isSelected ? 1 : 0.9 
            });
        });

        const thisRoute = routeLines.find(r => r.id === selectedRouteId);
        if (thisRoute) {
            map.fitBounds(thisRoute.line.getBounds());
        }

        document.getElementById("walkBtn").disabled = false;
    };

    document.getElementById("routesList").appendChild(div);
}

    function postLocationToServer(lat, lng) {
      fetch("/api/tourist_location", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ lat: lat, lng: lng, timestamp: new Date().toISOString() })
      });
    }

    function sendPlannedPath(path) {
        fetch("/api/planned_path", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ path: path.map(p => ({ lat: p[0], lng: p[1] })) })
        });
    }

    function checkAnomaly(lat, lng) {
        fetch("/api/check_anomaly", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ lat: lat, lng: lng })
        })
        .then(res => res.json())
        .then(data => {
            if (data.status === "anomaly" && data.anomalies) {
                data.anomalies.forEach(anomaly => {
                    if (anomaly.type === "approaching_danger_zone") {
                        if (!enteredZoneIds.has(anomaly.zone._id)) {
                            let now = Date.now();
                            if (now - lastApproachingAlert > APPROACHING_COOLDOWN) {
                                speak(`Warning: You are approaching a danger zone: ${anomaly.zone.description}`)
                                lastApproachingAlert = now;
                            }
                        }
                    } else if (anomaly.type === "danger_zone_entry") {
                        enteredZoneIds.add(anomaly.zone._id);
                        let now = Date.now();
                        if (now - lastDangerAlert > DANGER_COOLDOWN) {
                            const alertMsg = `DANGER: You have entered a high-risk zone: ${anomaly.zone.description}`;
                            speak(alertMsg);
                            playAudioAlert();
                            lastDangerAlert = now;
                        }
                    } else if (anomaly.type === "path_deviation") {
                        let now = Date.now();
                        if (now - lastDeviationAlert > DEVIATION_COOLDOWN) {
                            //speak("Sir, you are deviating from the path.");
                            //lastDeviationAlert = now;
                        }
                    }
                });
            }
        });
    }

    // Track current location
    var userMarker=null;
    if(navigator.geolocation){
      navigator.geolocation.watchPosition(pos=>{
        currentLocation=L.latLng(pos.coords.latitude,pos.coords.longitude);
        if(!userMarker){
            userMarker = L.circleMarker(currentLocation, { radius: 8, color: "green", fillColor: "green", fillOpacity: 1 }).addTo(map);
            userMarker.bindPopup("📍 You are here", { className: 'custom-popup light-popup' }).openPopup();
            map.setView(currentLocation,15);
        } else {
            userMarker.setLatLng(currentLocation);
        }

        // Perform geo-fencing check and location update
        checkAnomaly(currentLocation.lat, currentLocation.lng);
        postLocationToServer(currentLocation.lat, currentLocation.lng);
      });
    }
  </script>
</body>
</html>